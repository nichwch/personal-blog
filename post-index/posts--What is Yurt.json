{"": [{"content": "~", "parent": "Plaintext is your best friend.txt", "score": 0.6013116240501404}, {"content": "~", "parent": "Fragments.txt", "score": 0.6013129949569702}, {"content": "~", "parent": "untitled-1-4-2022.txt", "score": 0.6013137102127075}, {"content": "~", "parent": "What is Nomad Hypertext.txt", "score": 0.6013444587310941}, {"content": "~", "parent": "What is Nomad Hypertext.txt", "score": 0.6013444587310941}, {"content": "~", "parent": "What is Nomad Hypertext.txt", "score": 0.6013444587310941}, {"content": "~", "parent": "What is Nomad Hypertext.txt", "score": 0.6013444587310941}, {"content": "~", "parent": "Fragments.txt", "score": 0.6013447046279907}, {"content": "~", "parent": "Fragments.txt", "score": 0.6013447046279907}, {"content": "~", "parent": "Fragments.txt", "score": 0.6013447046279907}], "Yurt is a static site generator, built off the same principles as Nomad Hypertext. ": [{"content": "Yurt is a static site generator, built off the same principles as Nomad Hypertext. ", "parent": "What is Yurt.txt", "score": 7.748603820800781e-07}, {"content": "You're viewing this on a statically generated blog using Yurt! ", "parent": "What is Yurt.txt", "score": 0.36635977029800415}, {"content": "One last thing: There is a solution that combines the flexibility of plaintext with the aesthetics of rich text - Markdown! I don't think I'll support Markdown formatting in nomad hypertext, but for my static site generator Yurt, I will try to do that in the future. The utility would mostly be from having usable links. ", "parent": "Plaintext is your best friend.txt", "score": 0.39609426259994507}, {"content": "However, when building Yurt, the static site builder for nomad hypertext, I found myself repeating a lot of logic. I found myself wanting to add features to the indexing engine, like being able to use cloud providers instead of local models (because doing all this processing locally can take ages!). In the future, I might want to use multimodal models, so I can see similarity between images, text, and audio. \n\nFactoring out the semantic search element of my app would have been the correct, unix-ey thing to do, and it would allow me to make these extensions in the future. I plan on doing this soon.  ", "parent": "The making of Nomad Hypertext.txt", "score": 0.4047999978065491}, {"content": "There are pros and cons to this approach. The biggest pro is that it generates a static blog. There's no backend to maintain, and it's quite lightweight and loads fast, while also providing the benefit of semantic hyperlinks. The con is that since the index is precomputed, you can't search for arbitrary things like you can in nomad hypertext. ", "parent": "What is Yurt.txt", "score": 0.432583212852478}, {"content": "Nomad Hypertext is a writing app built around semantic search. ", "parent": "What is Nomad Hypertext.txt", "score": 0.45892590769301833}, {"content": "Edit: I have added very basic support for Markdown to Yurt - right now pretty much only links work.", "parent": "Plaintext is your best friend.txt", "score": 0.5185278654098511}, {"content": "To be frank, I made some regrettable engineering decisions while making Nomad Hypertext. I built this during my Recurse Center batch and was focused on getting a working prototype out, so some shortcuts were taken. Nevertheless, reflecting back, I would say these shortcuts were not worth it. \n\nThe two big shortcuts I took were using Javascript instead of Typescript and using Electron instead of Tauri. ", "parent": "The making of Nomad Hypertext.txt", "score": 0.5262584090232849}, {"content": "I'll end with a haiku. \n\nNomad Hypertext\nPowered by semantic search\nGives inspiration", "parent": "What is Nomad Hypertext.txt", "score": 0.533156293345367}, {"content": "I was greatly inspired by two blogposts. The first, [Hyperlink Maximalism](https://thesephist.com/posts/hyperlink/) by Linus Lee talks about generating hyperlinks automatically between documents, and comes with a [demo](https://notation.app) that made a deep impression on me. To be honest, nomad hypertext is just Linus' demo using semantic search instead of full text search.", "parent": "What is Nomad Hypertext.txt", "score": 0.5414681455348163}], "At build time, it embeds all your posts into vectors and puts them into a vector database. Then, for each paragraph in a post, it queries the vector database for the 20 most similar paragraphs from all your notes. It stores these in a precomputed index. It then statically generates a blog for you (like Gatsby or any other static site generator), and uses this index so users can see related ideas when they click on a paragraph.": [{"content": "At build time, it embeds all your posts into vectors and puts them into a vector database. Then, for each paragraph in a post, it queries the vector database for the 20 most similar paragraphs from all your notes. It stores these in a precomputed index. It then statically generates a blog for you (like Gatsby or any other static site generator), and uses this index so users can see related ideas when they click on a paragraph.", "parent": "What is Yurt.txt", "score": 1.1920928955078125e-07}, {"content": "It does this by dividing your notes up into paragraph-sized blocks and indexing them into a vector database with an AI embedding model.", "parent": "What is Nomad Hypertext.txt", "score": 0.3668214438826789}, {"content": "There are pros and cons to this approach. The biggest pro is that it generates a static blog. There's no backend to maintain, and it's quite lightweight and loads fast, while also providing the benefit of semantic hyperlinks. The con is that since the index is precomputed, you can't search for arbitrary things like you can in nomad hypertext. ", "parent": "What is Yurt.txt", "score": 0.4354630708694458}, {"content": "I rewrote the indexing software for this blog in Python. The general philosophy of keeping things as modular as possible, storing content in interoperable, plain formats whenever possible, has been paying off. I'm realizing slowly how many other possibilities are opened up by keeping content in plaintext/markdown - I can write a weekend project mapping my blog posts by topic and time, I can create a word cloud visualization of my blog, I can build a game of pong where the blocks are paragraphs of my blogposts, all without touching any existing code. ", "parent": "NOW PAGE.txt", "score": 0.49972105026245117}, {"content": "It's pretty simple for the most part, you just write. If you want to see ideas that are related to a paragraph, click the # next to the paragraph. ", "parent": "What is Nomad Hypertext.txt", "score": 0.5344508893970049}, {"content": "However, when building Yurt, the static site builder for nomad hypertext, I found myself repeating a lot of logic. I found myself wanting to add features to the indexing engine, like being able to use cloud providers instead of local models (because doing all this processing locally can take ages!). In the future, I might want to use multimodal models, so I can see similarity between images, text, and audio. \n\nFactoring out the semantic search element of my app would have been the correct, unix-ey thing to do, and it would allow me to make these extensions in the future. I plan on doing this soon.  ", "parent": "The making of Nomad Hypertext.txt", "score": 0.5443364381790161}, {"content": "You're viewing this on a statically generated blog using Yurt! ", "parent": "What is Yurt.txt", "score": 0.5461264848709106}, {"content": "I was greatly inspired by two blogposts. The first, [Hyperlink Maximalism](https://thesephist.com/posts/hyperlink/) by Linus Lee talks about generating hyperlinks automatically between documents, and comes with a [demo](https://notation.app) that made a deep impression on me. To be honest, nomad hypertext is just Linus' demo using semantic search instead of full text search.", "parent": "What is Nomad Hypertext.txt", "score": 0.551452717763448}, {"content": "The vision is to have a tool that provides a visual interface for creating layouts, and maybe even rigging up basic stateful logic, or data fetching logic. I've more or less nailed down a preferred personal stack for creating projects with React, Express and Postgres, so it shouldn't be terribly difficult to even integrate database logic/fetching logic into such a tool (so long as some flexibility is lost on technology choice).[[code]] [[ideas]] [[tools for thought]] ", "parent": "untitled-9-24-2021.txt", "score": 0.555728554725647}, {"content": "I think eventually, I might want to deploy a blog with a full fledged backend, so users can query anything they'd like to my blog. ", "parent": "What is Yurt.txt", "score": 0.5615641474723816}], "You're viewing this on a statically generated blog using Yurt! ": [{"content": "You're viewing this on a statically generated blog using Yurt! ", "parent": "What is Yurt.txt", "score": -3.5762786865234375e-07}, {"content": "Yurt is a static site generator, built off the same principles as Nomad Hypertext. ", "parent": "What is Yurt.txt", "score": 0.36633044481277466}, {"content": "Edit: I have added very basic support for Markdown to Yurt - right now pretty much only links work.", "parent": "Plaintext is your best friend.txt", "score": 0.45640504360198975}, {"content": "There are pros and cons to this approach. The biggest pro is that it generates a static blog. There's no backend to maintain, and it's quite lightweight and loads fast, while also providing the benefit of semantic hyperlinks. The con is that since the index is precomputed, you can't search for arbitrary things like you can in nomad hypertext. ", "parent": "What is Yurt.txt", "score": 0.5010294914245605}, {"content": "One last thing: There is a solution that combines the flexibility of plaintext with the aesthetics of rich text - Markdown! I don't think I'll support Markdown formatting in nomad hypertext, but for my static site generator Yurt, I will try to do that in the future. The utility would mostly be from having usable links. ", "parent": "Plaintext is your best friend.txt", "score": 0.5157318711280823}, {"content": "I rewrote the indexing software for this blog in Python. The general philosophy of keeping things as modular as possible, storing content in interoperable, plain formats whenever possible, has been paying off. I'm realizing slowly how many other possibilities are opened up by keeping content in plaintext/markdown - I can write a weekend project mapping my blog posts by topic and time, I can create a word cloud visualization of my blog, I can build a game of pong where the blocks are paragraphs of my blogposts, all without touching any existing code. ", "parent": "NOW PAGE.txt", "score": 0.5293707847595215}, {"content": "However, when building Yurt, the static site builder for nomad hypertext, I found myself repeating a lot of logic. I found myself wanting to add features to the indexing engine, like being able to use cloud providers instead of local models (because doing all this processing locally can take ages!). In the future, I might want to use multimodal models, so I can see similarity between images, text, and audio. \n\nFactoring out the semantic search element of my app would have been the correct, unix-ey thing to do, and it would allow me to make these extensions in the future. I plan on doing this soon.  ", "parent": "The making of Nomad Hypertext.txt", "score": 0.54447340965271}, {"content": "At build time, it embeds all your posts into vectors and puts them into a vector database. Then, for each paragraph in a post, it queries the vector database for the 20 most similar paragraphs from all your notes. It stores these in a precomputed index. It then statically generates a blog for you (like Gatsby or any other static site generator), and uses this index so users can see related ideas when they click on a paragraph.", "parent": "What is Yurt.txt", "score": 0.5461377501487732}, {"content": "I think eventually, I might want to deploy a blog with a full fledged backend, so users can query anything they'd like to my blog. ", "parent": "What is Yurt.txt", "score": 0.5656439065933228}, {"content": "This is not groundbreaking news, but it's groundbreaking for me. I started my software engineering career writing code with cloud applications in mind, and the idea that you can ship cool projects without running database migrations or doing extensive backtesting against your monolith *is* groundbreaking to me. In college I wanted my own blog and instead of getting a static site generator I built out a cloud application with NextJS, PostgreSQL and Heroku. I did learn a lot and it helped me land my first internship, but now it strikes me as an incredibly wrong minded approach. ", "parent": "NOW PAGE.txt", "score": 0.6017951965332031}], "There are pros and cons to this approach. The biggest pro is that it generates a static blog. There's no backend to maintain, and it's quite lightweight and loads fast, while also providing the benefit of semantic hyperlinks. The con is that since the index is precomputed, you can't search for arbitrary things like you can in nomad hypertext. ": [{"content": "There are pros and cons to this approach. The biggest pro is that it generates a static blog. There's no backend to maintain, and it's quite lightweight and loads fast, while also providing the benefit of semantic hyperlinks. The con is that since the index is precomputed, you can't search for arbitrary things like you can in nomad hypertext. ", "parent": "What is Yurt.txt", "score": -1.1920928955078125e-07}, {"content": "However, when building Yurt, the static site builder for nomad hypertext, I found myself repeating a lot of logic. I found myself wanting to add features to the indexing engine, like being able to use cloud providers instead of local models (because doing all this processing locally can take ages!). In the future, I might want to use multimodal models, so I can see similarity between images, text, and audio. \n\nFactoring out the semantic search element of my app would have been the correct, unix-ey thing to do, and it would allow me to make these extensions in the future. I plan on doing this soon.  ", "parent": "The making of Nomad Hypertext.txt", "score": 0.3991392254829407}, {"content": "I was greatly inspired by two blogposts. The first, [Hyperlink Maximalism](https://thesephist.com/posts/hyperlink/) by Linus Lee talks about generating hyperlinks automatically between documents, and comes with a [demo](https://notation.app) that made a deep impression on me. To be honest, nomad hypertext is just Linus' demo using semantic search instead of full text search.", "parent": "What is Nomad Hypertext.txt", "score": 0.40438753816284967}, {"content": "Nomad Hypertext is a writing app built around semantic search. ", "parent": "What is Nomad Hypertext.txt", "score": 0.4133148310458953}, {"content": "Yurt is a static site generator, built off the same principles as Nomad Hypertext. ", "parent": "What is Yurt.txt", "score": 0.4325941205024719}, {"content": "At build time, it embeds all your posts into vectors and puts them into a vector database. Then, for each paragraph in a post, it queries the vector database for the 20 most similar paragraphs from all your notes. It stores these in a precomputed index. It then statically generates a blog for you (like Gatsby or any other static site generator), and uses this index so users can see related ideas when they click on a paragraph.", "parent": "What is Yurt.txt", "score": 0.4354630708694458}, {"content": "One last thing: There is a solution that combines the flexibility of plaintext with the aesthetics of rich text - Markdown! I don't think I'll support Markdown formatting in nomad hypertext, but for my static site generator Yurt, I will try to do that in the future. The utility would mostly be from having usable links. ", "parent": "Plaintext is your best friend.txt", "score": 0.43765753507614136}, {"content": "I rewrote the indexing software for this blog in Python. The general philosophy of keeping things as modular as possible, storing content in interoperable, plain formats whenever possible, has been paying off. I'm realizing slowly how many other possibilities are opened up by keeping content in plaintext/markdown - I can write a weekend project mapping my blog posts by topic and time, I can create a word cloud visualization of my blog, I can build a game of pong where the blocks are paragraphs of my blogposts, all without touching any existing code. ", "parent": "NOW PAGE.txt", "score": 0.44937753677368164}, {"content": "I'll end with a haiku. \n\nNomad Hypertext\nPowered by semantic search\nGives inspiration", "parent": "What is Nomad Hypertext.txt", "score": 0.4587320324615317}, {"content": "At the Recurse center, grinding leetcode and working on nomad hypertext, a collection of interface ideas that center around local-first notetaking powered by semantic search and AI. ", "parent": "NOW-Jan-05-2024.txt", "score": 0.5002481937408447}], "I think eventually, I might want to deploy a blog with a full fledged backend, so users can query anything they'd like to my blog. ": [{"content": "I think eventually, I might want to deploy a blog with a full fledged backend, so users can query anything they'd like to my blog. ", "parent": "What is Yurt.txt", "score": -3.5762786865234375e-07}, {"content": "I rewrote the indexing software for this blog in Python. The general philosophy of keeping things as modular as possible, storing content in interoperable, plain formats whenever possible, has been paying off. I'm realizing slowly how many other possibilities are opened up by keeping content in plaintext/markdown - I can write a weekend project mapping my blog posts by topic and time, I can create a word cloud visualization of my blog, I can build a game of pong where the blocks are paragraphs of my blogposts, all without touching any existing code. ", "parent": "NOW PAGE.txt", "score": 0.4653310775756836}, {"content": "However, when building Yurt, the static site builder for nomad hypertext, I found myself repeating a lot of logic. I found myself wanting to add features to the indexing engine, like being able to use cloud providers instead of local models (because doing all this processing locally can take ages!). In the future, I might want to use multimodal models, so I can see similarity between images, text, and audio. \n\nFactoring out the semantic search element of my app would have been the correct, unix-ey thing to do, and it would allow me to make these extensions in the future. I plan on doing this soon.  ", "parent": "The making of Nomad Hypertext.txt", "score": 0.49382948875427246}, {"content": "There are pros and cons to this approach. The biggest pro is that it generates a static blog. There's no backend to maintain, and it's quite lightweight and loads fast, while also providing the benefit of semantic hyperlinks. The con is that since the index is precomputed, you can't search for arbitrary things like you can in nomad hypertext. ", "parent": "What is Yurt.txt", "score": 0.5029909610748291}, {"content": "I want to continue working on [[exegesis]]. There are still a plethora of features I want to build into the app. I have wanted to build something like this for a long time - I sort of did with my last project [YANA](https://yananotes.com/), but the core text engine was so limited that I had to start over from scratch (the product of which is exegesis). I want to sort out a formal list of features before a beta release, and an eventual public release. I will probably use exegesis as a devlog of sorts as well.", "parent": "Reflections for the New Year.txt", "score": 0.5103234052658081}, {"content": "This is not groundbreaking news, but it's groundbreaking for me. I started my software engineering career writing code with cloud applications in mind, and the idea that you can ship cool projects without running database migrations or doing extensive backtesting against your monolith *is* groundbreaking to me. In college I wanted my own blog and instead of getting a static site generator I built out a cloud application with NextJS, PostgreSQL and Heroku. I did learn a lot and it helped me land my first internship, but now it strikes me as an incredibly wrong minded approach. ", "parent": "NOW PAGE.txt", "score": 0.5263653993606567}, {"content": "The vision is to have a tool that provides a visual interface for creating layouts, and maybe even rigging up basic stateful logic, or data fetching logic. I've more or less nailed down a preferred personal stack for creating projects with React, Express and Postgres, so it shouldn't be terribly difficult to even integrate database logic/fetching logic into such a tool (so long as some flexibility is lost on technology choice).[[code]] [[ideas]] [[tools for thought]] ", "parent": "untitled-9-24-2021.txt", "score": 0.5373309850692749}, {"content": "Eventually I want exegesis to be a social platform - you can already publish notes, but I want social features like profiles, groups, follows, etc. etc. Similar tools like [[roam]] can already be used as CRMs. So can exegesis. But, if I'm going to be building profiles into the app for social features, it may make sense to build additional affordances around managing people and relationships. For example, hovering over a link to a person could show all their social media profiles, in addition to places where you've tagged them in your notes.[[exegesis]] [[ideas]] [[roam]] ", "parent": "untitled-9-20-2021.txt", "score": 0.5446465611457825}, {"content": "To make regular progress towards personal projects, I'll be writing more on my development progress with [[exegesis]], under the tag [[devlog]]. I'll also be publishing another post soon on my plans for future features, and when I expect to release them by. I will do something similar with my other projects.", "parent": "Goals for Spring Quarter.txt", "score": 0.5483261942863464}, {"content": "I had some interesting ideas this morning on exegesis. The future of [[tools for thought]] should be social, and maybe people and profiles should be first order features in exegesis. Let me clarify what I mean by this. Right now, exegesis' model is very simple: you have pages, and you have tags that you can apply to pages and parts of pages. If there's a tag that has the same title as a page, clicking the tag will lead you to the page, and the page will show everywhere it's been linked. Simple, basic, backlinking. [[exegesis]] [[ideas]] [[tools for thought]] ", "parent": "untitled-9-20-2021.txt", "score": 0.5589262247085571}]}