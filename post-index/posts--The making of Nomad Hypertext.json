{"~": [{"content": "~", "parent": "Fragments.txt", "score": -3.5762786865234375e-07}, {"content": "~", "parent": "Fragments.txt", "score": 0.0}, {"content": "~", "parent": "Fragments.txt", "score": 0.0}, {"content": "~", "parent": "Fragments.txt", "score": 0.0}, {"content": "~", "parent": "Fragments.txt", "score": 0.0}, {"content": "~", "parent": "Fragments.txt", "score": 0.0}, {"content": "~", "parent": "untitled-1-4-2022.txt", "score": 0.0}, {"content": "~", "parent": "The making of Nomad Hypertext.txt", "score": 0.0}, {"content": "~", "parent": "untitled-1-4-2022.txt", "score": 0.0}, {"content": "~", "parent": "Second Brains.txt", "score": 0.0}], "To be frank, I made some regrettable engineering decisions while making Nomad Hypertext. I built this during my Recurse Center batch and was focused on getting a working prototype out, so some shortcuts were taken. Nevertheless, reflecting back, I would say these shortcuts were not worth it. ": [{"content": "To be frank, I made some regrettable engineering decisions while making Nomad Hypertext. I built this during my Recurse Center batch and was focused on getting a working prototype out, so some shortcuts were taken. Nevertheless, reflecting back, I would say these shortcuts were not worth it. ", "parent": "The making of Nomad Hypertext.txt", "score": 1.6689300537109375e-06}, {"content": "That's why I picked the name nomad hypertext. ", "parent": "What is Nomad Hypertext.txt", "score": 0.43700557947158813}, {"content": "At the Recurse center, grinding leetcode and working on nomad hypertext, a collection of interface ideas that center around local-first notetaking powered by semantic search and AI. ", "parent": "NOW-Jan-05-2024.txt", "score": 0.4400792121887207}, {"content": "Working on exegesis was a grueling affair at times. I rewrote the schema multiple times, rewrote the backend from scratch 2 months before release, chased countless UI bugs, and manually patched abandoned NPM packages. Part of it may have been due to my inexperience, but [working with ](https://nichwch.medium.com/making-yana-e3fade3f56e7)[rich text](https://medium.engineering/why-contenteditable-is-terrible-122d8a40e480) is just a [difficult task](https://twitter.com/thesephist/status/1360298464349999108), period. At one point, I considered giving up after finding a rival writing app I thought I simply couldn't compete with - I have a copy of an unfinished essay I started writing on why I had given up tucked away somewhere. ", "parent": "Prometheus.txt", "score": 0.444637656211853}, {"content": "Nomad Hypertext", "parent": "What is Nomad Hypertext.txt", "score": 0.47283282596875165}, {"content": "However, when building Yurt, the static site builder for nomad hypertext, I found myself repeating a lot of logic. I found myself wanting to add features to the indexing engine, like being able to use cloud providers instead of local models (because doing all this processing locally can take ages!). In the future, I might want to use multimodal models, so I can see similarity between images, text, and audio. ", "parent": "The making of Nomad Hypertext.txt", "score": 0.48096948862075806}, {"content": "I fell into this kind of thinking while building exegesis, and it put an enormous amount of pressure on me, because it made me feel as if it wasn't just a notetaking app I was building, but a shrine for the mind. I would look at other notetaking systems like Roam Research and feel threatened - my notetaking app wasn't as powerful as theirs, therefore my mind would be weaker than theirs. Every little imperfection, every unimplemented feature, every bug felt sacrilegious - this was my second brain I was building after all. Needless to say, this led to a lot of feature creep, because my second brain had to be perfect.", "parent": "Second Brains.txt", "score": 0.4886259436607361}, {"content": "I avoided this IPC-executable approach because I thought it'd be really complicated. To some extent, this was the correct decision - I'm glad I got a MVP of my project out during my time at Recurse. ", "parent": "The making of Nomad Hypertext.txt", "score": 0.49307340383529663}, {"content": "Why did it take so long? Part of it is just a lack of experience. While making exegesis, I changed the database schema countless times, wrote dozens of migrations, accidentally wiped my database once (thank God for RDS backups), and rewrote the backend from scratch 2 months before release. There was also a good amount of feature creep. Whenever I thought I was close to finished, something unexpected would pop up - I started writing this essay 3 months before I actually released exegesis. Whatever the reason, if you count development time on the predecessor to exegesis, I've spent almost a tenth of my life building this. The entire project clocks in at a couple thousand lines of code. It is the largest, most complex, and most difficult thing I have built so far in my life.  [The last time I worked on a project this long, it was the first video game I made back in my senior year of high school.](https://medium.com/@nichwch/machine-gods-devlog-1-166dff474366) Even then, it was really about 6 months of development total, with a huge gap in between because of school, and it was all made with no-code game development tools, because back then the idea of using actual code terrified me. [[exegesis]] [[personal-reflection]] ", "parent": "Reflections on exegesis.txt", "score": 0.5079221725463867}, {"content": "I was greatly inspired by two blogposts. The first, [Hyperlink Maximalism](https://thesephist.com/posts/hyperlink/) by Linus Lee talks about generating hyperlinks automatically between documents, and comes with a [demo](https://notation.app) that made a deep impression on me. To be honest, nomad hypertext is just Linus' demo using semantic search instead of full text search.", "parent": "What is Nomad Hypertext.txt", "score": 0.5107406973838806}], "": [{"content": "~", "parent": "What is Nomad Hypertext.txt", "score": 0.6012972593307495}, {"content": "~", "parent": "The making of Nomad Hypertext.txt", "score": 0.6013116240501404}, {"content": "~", "parent": "What is Nomad Hypertext.txt", "score": 0.6013116240501404}, {"content": "~", "parent": "What is Nomad Hypertext.txt", "score": 0.6013116240501404}, {"content": "~", "parent": "Fragments.txt", "score": 0.6013129949569702}, {"content": "~", "parent": "What is Nomad Hypertext.txt", "score": 0.6013135506879113}, {"content": "~", "parent": "Second Brains.txt", "score": 0.6013180017471313}, {"content": "~", "parent": "Fragments.txt", "score": 0.6013447046279907}, {"content": "~", "parent": "untitled-1-4-2022.txt", "score": 0.6013447046279907}, {"content": "~", "parent": "The making of Nomad Hypertext.txt", "score": 0.6013447046279907}], "The two big shortcuts I took were using Javascript instead of Typescript and using Electron instead of Tauri. ": [{"content": "The two big shortcuts I took were using Javascript instead of Typescript and using Electron instead of Tauri. ", "parent": "The making of Nomad Hypertext.txt", "score": -1.1920928955078125e-07}, {"content": "I opted to use Javascript instead of Typescript out of mix of curiosity and laziness. Like most people, I was introduced to Javascript before I was introduced to Typescript. Like most people, I suffered through many null errors and was relieved when I discovered that the Typescript compiler could save me from many of them. Like most people, though I am grateful for Typescript, I find it occasionally cumbersome. ", "parent": "The making of Nomad Hypertext.txt", "score": 0.3857993483543396}, {"content": "The results were... mixed. I did get to move faster at the start, but started running into more and more type-related bugs as development went on. If I were to do this project again, I'd stick to Typescript. ", "parent": "The making of Nomad Hypertext.txt", "score": 0.4226003885269165}, {"content": "Why not Tauri? With Tauri you have to write your backend routes in Rust. Surprisingly, I could not find any in-memory vector databases in Rust. I also have never written Rust in my life, though I would have been happy to pick it up to avoid using Electron. More importantly, I don't think there was a library that would have let me run Hugging Face's text embedding model in Rust. For these reasons, I had to use JS for my backend, which meant I had to use Electron. ", "parent": "The making of Nomad Hypertext.txt", "score": 0.43955403566360474}, {"content": "I read Rich Harris' twitter thread on how Javascript with JSDoc is actually pretty good, and decided to give it a shot. To be clear, I'm not blaming Rich Harris for my choice - he qualified his point, saying JS with JSDoc is preferable to Typescript for library development, because not having an intermediate build step makes it easier to reproduce bugs in a REPL. He still recommends using Typescript for projects (I think), so I was acting against his advice here. ", "parent": "The making of Nomad Hypertext.txt", "score": 0.4496700167655945}, {"content": "Electron really, really, really sucks. For starters, you have to use CommonJS. That itself would be bad enough, but there are a huge pile of other inconveniences that Electron dumps on you: Using window.prompt() doesn't work (because it blocks the main thread apparently) and it generates HUGE executables without making the slightest effort to tree-shake anything (it was literally bundling in sample text files I was using in the repo). Creating my own window.prompt() alternative was an interesting exercise, but I wish I wasn't forced into doing it.", "parent": "The making of Nomad Hypertext.txt", "score": 0.4804677963256836}, {"content": "In any case I wanted to try something new because that's what Recurse is all about, so I tried making a project with just JS and JSDoc for some semblance of type safety. ", "parent": "The making of Nomad Hypertext.txt", "score": 0.4885091185569763}, {"content": "You might object: Just because the vector DB and text embedding model are tied to JS doesn't mean your whole application does! You'd be right. I could have rolled the vector DB and text embedding model into a separate executable, compiling a node wrapper around those libraries into their own executables, then calling those executables from my Tauri app with IPC.", "parent": "The making of Nomad Hypertext.txt", "score": 0.5181077718734741}, {"content": "To be frank, I made some regrettable engineering decisions while making Nomad Hypertext. I built this during my Recurse Center batch and was focused on getting a working prototype out, so some shortcuts were taken. Nevertheless, reflecting back, I would say these shortcuts were not worth it. ", "parent": "The making of Nomad Hypertext.txt", "score": 0.5327475070953369}, {"content": "I want to learn more code. Working on [[exegesis]] over the course of a year, I saw my coding ability improve substantially. Towards the last 2 months, while rewriting a part of the codebase, I found myself dumbfounded by some of the decisions and patterns I had used a year earlier. The code I wrote towards the end was noticeably cleaner and more maintainable, mostly because I had familiarized myself with [[React]] hooks. Learning NextJS and GraphQL was also very rewarding, and both technologies were used extensively in the final version of exegesis. Looking forwards, I am thinking about learning Go, Clojure and maybe Rust. Go is the most practical one of all these for my purposes, and could open up a lot of job offers. Clojure is the most interesting from a theoretical standpoint, since I've never used a lisp or functional language. Rust is interesting because I hate systems/low-level programming, but I suspect that might only be because I hate C, and maybe Rust's more modern features will sell me on it. ", "parent": "Reflections for the New Year.txt", "score": 0.547896683216095}], "I opted to use Javascript instead of Typescript out of mix of curiosity and laziness. Like most people, I was introduced to Javascript before I was introduced to Typescript. Like most people, I suffered through many null errors and was relieved when I discovered that the Typescript compiler could save me from many of them. Like most people, though I am grateful for Typescript, I find it occasionally cumbersome. ": [{"content": "I opted to use Javascript instead of Typescript out of mix of curiosity and laziness. Like most people, I was introduced to Javascript before I was introduced to Typescript. Like most people, I suffered through many null errors and was relieved when I discovered that the Typescript compiler could save me from many of them. Like most people, though I am grateful for Typescript, I find it occasionally cumbersome. ", "parent": "The making of Nomad Hypertext.txt", "score": 2.980232238769531e-07}, {"content": "I read Rich Harris' twitter thread on how Javascript with JSDoc is actually pretty good, and decided to give it a shot. To be clear, I'm not blaming Rich Harris for my choice - he qualified his point, saying JS with JSDoc is preferable to Typescript for library development, because not having an intermediate build step makes it easier to reproduce bugs in a REPL. He still recommends using Typescript for projects (I think), so I was acting against his advice here. ", "parent": "The making of Nomad Hypertext.txt", "score": 0.37853193283081055}, {"content": "The two big shortcuts I took were using Javascript instead of Typescript and using Electron instead of Tauri. ", "parent": "The making of Nomad Hypertext.txt", "score": 0.38581305742263794}, {"content": "The results were... mixed. I did get to move faster at the start, but started running into more and more type-related bugs as development went on. If I were to do this project again, I'd stick to Typescript. ", "parent": "The making of Nomad Hypertext.txt", "score": 0.41377437114715576}, {"content": "In any case I wanted to try something new because that's what Recurse is all about, so I tried making a project with just JS and JSDoc for some semblance of type safety. ", "parent": "The making of Nomad Hypertext.txt", "score": 0.46273666620254517}, {"content": "I want to learn more code. Working on [[exegesis]] over the course of a year, I saw my coding ability improve substantially. Towards the last 2 months, while rewriting a part of the codebase, I found myself dumbfounded by some of the decisions and patterns I had used a year earlier. The code I wrote towards the end was noticeably cleaner and more maintainable, mostly because I had familiarized myself with [[React]] hooks. Learning NextJS and GraphQL was also very rewarding, and both technologies were used extensively in the final version of exegesis. Looking forwards, I am thinking about learning Go, Clojure and maybe Rust. Go is the most practical one of all these for my purposes, and could open up a lot of job offers. Clojure is the most interesting from a theoretical standpoint, since I've never used a lisp or functional language. Rust is interesting because I hate systems/low-level programming, but I suspect that might only be because I hate C, and maybe Rust's more modern features will sell me on it. ", "parent": "Reflections for the New Year.txt", "score": 0.5246422290802002}, {"content": "Learning Javascript, I never took notes, because all the reference docs were online anyways. Besides, the difficult part of programming isn't remembering APIs, it's the process of taking an idea and building it out, and there's no way to get better at that except by building. There's a reason most university CS courses don't test memorization heavily and instead focus on having students build projects. I suspect this is true for a lot of subjects.", "parent": "On tools for thought: knowledge management vs creativity.txt", "score": 0.5338748693466187}, {"content": "Why not Tauri? With Tauri you have to write your backend routes in Rust. Surprisingly, I could not find any in-memory vector databases in Rust. I also have never written Rust in my life, though I would have been happy to pick it up to avoid using Electron. More importantly, I don't think there was a library that would have let me run Hugging Face's text embedding model in Rust. For these reasons, I had to use JS for my backend, which meant I had to use Electron. ", "parent": "The making of Nomad Hypertext.txt", "score": 0.5549277067184448}, {"content": "[[ideas]]: As I've matured as a [[React]] developer, I've found certain standard methods of handling things like state management, routing, styling, and data fetching. Because I've standardized on this approach, I've been writing higher order functions that abstract away a lot of the boilerplate. This has me thinking - it would almost certainly be possible to build some kind of visual tool to help scaffold a react app. Something in between no-code and a developer tool - like the [Nx.dev extension for VSCode](https://marketplace.visualstudio.com/items?itemName=nrwl.angular-console). [[code]] ", "parent": "untitled-9-20-2021.txt", "score": 0.5621135234832764}, {"content": "Electron really, really, really sucks. For starters, you have to use CommonJS. That itself would be bad enough, but there are a huge pile of other inconveniences that Electron dumps on you: Using window.prompt() doesn't work (because it blocks the main thread apparently) and it generates HUGE executables without making the slightest effort to tree-shake anything (it was literally bundling in sample text files I was using in the repo). Creating my own window.prompt() alternative was an interesting exercise, but I wish I wasn't forced into doing it.", "parent": "The making of Nomad Hypertext.txt", "score": 0.5723724365234375}], "I read Rich Harris' twitter thread on how Javascript with JSDoc is actually pretty good, and decided to give it a shot. To be clear, I'm not blaming Rich Harris for my choice - he qualified his point, saying JS with JSDoc is preferable to Typescript for library development, because not having an intermediate build step makes it easier to reproduce bugs in a REPL. He still recommends using Typescript for projects (I think), so I was acting against his advice here. ": [{"content": "I read Rich Harris' twitter thread on how Javascript with JSDoc is actually pretty good, and decided to give it a shot. To be clear, I'm not blaming Rich Harris for my choice - he qualified his point, saying JS with JSDoc is preferable to Typescript for library development, because not having an intermediate build step makes it easier to reproduce bugs in a REPL. He still recommends using Typescript for projects (I think), so I was acting against his advice here. ", "parent": "The making of Nomad Hypertext.txt", "score": -5.960464477539062e-07}, {"content": "In any case I wanted to try something new because that's what Recurse is all about, so I tried making a project with just JS and JSDoc for some semblance of type safety. ", "parent": "The making of Nomad Hypertext.txt", "score": 0.30753445625305176}, {"content": "I opted to use Javascript instead of Typescript out of mix of curiosity and laziness. Like most people, I was introduced to Javascript before I was introduced to Typescript. Like most people, I suffered through many null errors and was relieved when I discovered that the Typescript compiler could save me from many of them. Like most people, though I am grateful for Typescript, I find it occasionally cumbersome. ", "parent": "The making of Nomad Hypertext.txt", "score": 0.37855565547943115}, {"content": "The two big shortcuts I took were using Javascript instead of Typescript and using Electron instead of Tauri. ", "parent": "The making of Nomad Hypertext.txt", "score": 0.44964706897735596}, {"content": "The results were... mixed. I did get to move faster at the start, but started running into more and more type-related bugs as development went on. If I were to do this project again, I'd stick to Typescript. ", "parent": "The making of Nomad Hypertext.txt", "score": 0.4515116214752197}, {"content": "I want to learn more code. Working on [[exegesis]] over the course of a year, I saw my coding ability improve substantially. Towards the last 2 months, while rewriting a part of the codebase, I found myself dumbfounded by some of the decisions and patterns I had used a year earlier. The code I wrote towards the end was noticeably cleaner and more maintainable, mostly because I had familiarized myself with [[React]] hooks. Learning NextJS and GraphQL was also very rewarding, and both technologies were used extensively in the final version of exegesis. Looking forwards, I am thinking about learning Go, Clojure and maybe Rust. Go is the most practical one of all these for my purposes, and could open up a lot of job offers. Clojure is the most interesting from a theoretical standpoint, since I've never used a lisp or functional language. Rust is interesting because I hate systems/low-level programming, but I suspect that might only be because I hate C, and maybe Rust's more modern features will sell me on it. ", "parent": "Reflections for the New Year.txt", "score": 0.490497887134552}, {"content": "[[ideas]]: As I've matured as a [[React]] developer, I've found certain standard methods of handling things like state management, routing, styling, and data fetching. Because I've standardized on this approach, I've been writing higher order functions that abstract away a lot of the boilerplate. This has me thinking - it would almost certainly be possible to build some kind of visual tool to help scaffold a react app. Something in between no-code and a developer tool - like the [Nx.dev extension for VSCode](https://marketplace.visualstudio.com/items?itemName=nrwl.angular-console). [[code]] ", "parent": "untitled-9-20-2021.txt", "score": 0.5157521963119507}, {"content": "Learning Javascript, I never took notes, because all the reference docs were online anyways. Besides, the difficult part of programming isn't remembering APIs, it's the process of taking an idea and building it out, and there's no way to get better at that except by building. There's a reason most university CS courses don't test memorization heavily and instead focus on having students build projects. I suspect this is true for a lot of subjects.", "parent": "On tools for thought: knowledge management vs creativity.txt", "score": 0.5251433253288269}, {"content": "Working on exegesis was a grueling affair at times. I rewrote the schema multiple times, rewrote the backend from scratch 2 months before release, chased countless UI bugs, and manually patched abandoned NPM packages. Part of it may have been due to my inexperience, but [working with ](https://nichwch.medium.com/making-yana-e3fade3f56e7)[rich text](https://medium.engineering/why-contenteditable-is-terrible-122d8a40e480) is just a [difficult task](https://twitter.com/thesephist/status/1360298464349999108), period. At one point, I considered giving up after finding a rival writing app I thought I simply couldn't compete with - I have a copy of an unfinished essay I started writing on why I had given up tucked away somewhere. ", "parent": "Prometheus.txt", "score": 0.5350568294525146}, {"content": "Electron really, really, really sucks. For starters, you have to use CommonJS. That itself would be bad enough, but there are a huge pile of other inconveniences that Electron dumps on you: Using window.prompt() doesn't work (because it blocks the main thread apparently) and it generates HUGE executables without making the slightest effort to tree-shake anything (it was literally bundling in sample text files I was using in the repo). Creating my own window.prompt() alternative was an interesting exercise, but I wish I wasn't forced into doing it.", "parent": "The making of Nomad Hypertext.txt", "score": 0.5508072376251221}], "In any case I wanted to try something new because that's what Recurse is all about, so I tried making a project with just JS and JSDoc for some semblance of type safety. ": [{"content": "In any case I wanted to try something new because that's what Recurse is all about, so I tried making a project with just JS and JSDoc for some semblance of type safety. ", "parent": "The making of Nomad Hypertext.txt", "score": -4.76837158203125e-07}, {"content": "I read Rich Harris' twitter thread on how Javascript with JSDoc is actually pretty good, and decided to give it a shot. To be clear, I'm not blaming Rich Harris for my choice - he qualified his point, saying JS with JSDoc is preferable to Typescript for library development, because not having an intermediate build step makes it easier to reproduce bugs in a REPL. He still recommends using Typescript for projects (I think), so I was acting against his advice here. ", "parent": "The making of Nomad Hypertext.txt", "score": 0.30758142471313477}, {"content": "I opted to use Javascript instead of Typescript out of mix of curiosity and laziness. Like most people, I was introduced to Javascript before I was introduced to Typescript. Like most people, I suffered through many null errors and was relieved when I discovered that the Typescript compiler could save me from many of them. Like most people, though I am grateful for Typescript, I find it occasionally cumbersome. ", "parent": "The making of Nomad Hypertext.txt", "score": 0.46276819705963135}, {"content": "The results were... mixed. I did get to move faster at the start, but started running into more and more type-related bugs as development went on. If I were to do this project again, I'd stick to Typescript. ", "parent": "The making of Nomad Hypertext.txt", "score": 0.46531808376312256}, {"content": "I want to learn more code. Working on [[exegesis]] over the course of a year, I saw my coding ability improve substantially. Towards the last 2 months, while rewriting a part of the codebase, I found myself dumbfounded by some of the decisions and patterns I had used a year earlier. The code I wrote towards the end was noticeably cleaner and more maintainable, mostly because I had familiarized myself with [[React]] hooks. Learning NextJS and GraphQL was also very rewarding, and both technologies were used extensively in the final version of exegesis. Looking forwards, I am thinking about learning Go, Clojure and maybe Rust. Go is the most practical one of all these for my purposes, and could open up a lot of job offers. Clojure is the most interesting from a theoretical standpoint, since I've never used a lisp or functional language. Rust is interesting because I hate systems/low-level programming, but I suspect that might only be because I hate C, and maybe Rust's more modern features will sell me on it. ", "parent": "Reflections for the New Year.txt", "score": 0.4767969846725464}, {"content": "The two big shortcuts I took were using Javascript instead of Typescript and using Electron instead of Tauri. ", "parent": "The making of Nomad Hypertext.txt", "score": 0.488525390625}, {"content": "[[ideas]]: As I've matured as a [[React]] developer, I've found certain standard methods of handling things like state management, routing, styling, and data fetching. Because I've standardized on this approach, I've been writing higher order functions that abstract away a lot of the boilerplate. This has me thinking - it would almost certainly be possible to build some kind of visual tool to help scaffold a react app. Something in between no-code and a developer tool - like the [Nx.dev extension for VSCode](https://marketplace.visualstudio.com/items?itemName=nrwl.angular-console). [[code]] ", "parent": "untitled-9-20-2021.txt", "score": 0.5021057724952698}, {"content": "The vision is to have a tool that provides a visual interface for creating layouts, and maybe even rigging up basic stateful logic, or data fetching logic. I've more or less nailed down a preferred personal stack for creating projects with React, Express and Postgres, so it shouldn't be terribly difficult to even integrate database logic/fetching logic into such a tool (so long as some flexibility is lost on technology choice).[[code]] [[ideas]] [[tools for thought]] ", "parent": "untitled-9-24-2021.txt", "score": 0.5171921253204346}, {"content": "I avoided this IPC-executable approach because I thought it'd be really complicated. To some extent, this was the correct decision - I'm glad I got a MVP of my project out during my time at Recurse. ", "parent": "The making of Nomad Hypertext.txt", "score": 0.5237320065498352}, {"content": "Working on exegesis was a grueling affair at times. I rewrote the schema multiple times, rewrote the backend from scratch 2 months before release, chased countless UI bugs, and manually patched abandoned NPM packages. Part of it may have been due to my inexperience, but [working with ](https://nichwch.medium.com/making-yana-e3fade3f56e7)[rich text](https://medium.engineering/why-contenteditable-is-terrible-122d8a40e480) is just a [difficult task](https://twitter.com/thesephist/status/1360298464349999108), period. At one point, I considered giving up after finding a rival writing app I thought I simply couldn't compete with - I have a copy of an unfinished essay I started writing on why I had given up tucked away somewhere. ", "parent": "Prometheus.txt", "score": 0.5241909027099609}], "The results were... mixed. I did get to move faster at the start, but started running into more and more type-related bugs as development went on. If I were to do this project again, I'd stick to Typescript. ": [{"content": "The results were... mixed. I did get to move faster at the start, but started running into more and more type-related bugs as development went on. If I were to do this project again, I'd stick to Typescript. ", "parent": "The making of Nomad Hypertext.txt", "score": 1.1920928955078125e-06}, {"content": "I opted to use Javascript instead of Typescript out of mix of curiosity and laziness. Like most people, I was introduced to Javascript before I was introduced to Typescript. Like most people, I suffered through many null errors and was relieved when I discovered that the Typescript compiler could save me from many of them. Like most people, though I am grateful for Typescript, I find it occasionally cumbersome. ", "parent": "The making of Nomad Hypertext.txt", "score": 0.41387641429901123}, {"content": "The two big shortcuts I took were using Javascript instead of Typescript and using Electron instead of Tauri. ", "parent": "The making of Nomad Hypertext.txt", "score": 0.4226186275482178}, {"content": "I read Rich Harris' twitter thread on how Javascript with JSDoc is actually pretty good, and decided to give it a shot. To be clear, I'm not blaming Rich Harris for my choice - he qualified his point, saying JS with JSDoc is preferable to Typescript for library development, because not having an intermediate build step makes it easier to reproduce bugs in a REPL. He still recommends using Typescript for projects (I think), so I was acting against his advice here. ", "parent": "The making of Nomad Hypertext.txt", "score": 0.45162779092788696}, {"content": "In any case I wanted to try something new because that's what Recurse is all about, so I tried making a project with just JS and JSDoc for some semblance of type safety. ", "parent": "The making of Nomad Hypertext.txt", "score": 0.46534818410873413}, {"content": "Working on exegesis was a grueling affair at times. I rewrote the schema multiple times, rewrote the backend from scratch 2 months before release, chased countless UI bugs, and manually patched abandoned NPM packages. Part of it may have been due to my inexperience, but [working with ](https://nichwch.medium.com/making-yana-e3fade3f56e7)[rich text](https://medium.engineering/why-contenteditable-is-terrible-122d8a40e480) is just a [difficult task](https://twitter.com/thesephist/status/1360298464349999108), period. At one point, I considered giving up after finding a rival writing app I thought I simply couldn't compete with - I have a copy of an unfinished essay I started writing on why I had given up tucked away somewhere. ", "parent": "Prometheus.txt", "score": 0.49600595235824585}, {"content": "I want to learn more code. Working on [[exegesis]] over the course of a year, I saw my coding ability improve substantially. Towards the last 2 months, while rewriting a part of the codebase, I found myself dumbfounded by some of the decisions and patterns I had used a year earlier. The code I wrote towards the end was noticeably cleaner and more maintainable, mostly because I had familiarized myself with [[React]] hooks. Learning NextJS and GraphQL was also very rewarding, and both technologies were used extensively in the final version of exegesis. Looking forwards, I am thinking about learning Go, Clojure and maybe Rust. Go is the most practical one of all these for my purposes, and could open up a lot of job offers. Clojure is the most interesting from a theoretical standpoint, since I've never used a lisp or functional language. Rust is interesting because I hate systems/low-level programming, but I suspect that might only be because I hate C, and maybe Rust's more modern features will sell me on it. ", "parent": "Reflections for the New Year.txt", "score": 0.5027843713760376}, {"content": "I avoided this IPC-executable approach because I thought it'd be really complicated. To some extent, this was the correct decision - I'm glad I got a MVP of my project out during my time at Recurse. ", "parent": "The making of Nomad Hypertext.txt", "score": 0.5393342971801758}, {"content": "To be frank, I made some regrettable engineering decisions while making Nomad Hypertext. I built this during my Recurse Center batch and was focused on getting a working prototype out, so some shortcuts were taken. Nevertheless, reflecting back, I would say these shortcuts were not worth it. ", "parent": "The making of Nomad Hypertext.txt", "score": 0.5564064979553223}, {"content": "There was a problem with both of these outlets, however: my short attention span. I struggled to work on larger drawings, because I'd give up on them and start new doodles. The same happened with code projects.", "parent": "Fragments.txt", "score": 0.5711293816566467}], "Electron really, really, really sucks. For starters, you have to use CommonJS. That itself would be bad enough, but there are a huge pile of other inconveniences that Electron dumps on you: Using window.prompt() doesn't work (because it blocks the main thread apparently) and it generates HUGE executables without making the slightest effort to tree-shake anything (it was literally bundling in sample text files I was using in the repo). Creating my own window.prompt() alternative was an interesting exercise, but I wish I wasn't forced into doing it.": [{"content": "Electron really, really, really sucks. For starters, you have to use CommonJS. That itself would be bad enough, but there are a huge pile of other inconveniences that Electron dumps on you: Using window.prompt() doesn't work (because it blocks the main thread apparently) and it generates HUGE executables without making the slightest effort to tree-shake anything (it was literally bundling in sample text files I was using in the repo). Creating my own window.prompt() alternative was an interesting exercise, but I wish I wasn't forced into doing it.", "parent": "The making of Nomad Hypertext.txt", "score": -2.384185791015625e-07}, {"content": "The two big shortcuts I took were using Javascript instead of Typescript and using Electron instead of Tauri. ", "parent": "The making of Nomad Hypertext.txt", "score": 0.4804677963256836}, {"content": "Working on exegesis was a grueling affair at times. I rewrote the schema multiple times, rewrote the backend from scratch 2 months before release, chased countless UI bugs, and manually patched abandoned NPM packages. Part of it may have been due to my inexperience, but [working with ](https://nichwch.medium.com/making-yana-e3fade3f56e7)[rich text](https://medium.engineering/why-contenteditable-is-terrible-122d8a40e480) is just a [difficult task](https://twitter.com/thesephist/status/1360298464349999108), period. At one point, I considered giving up after finding a rival writing app I thought I simply couldn't compete with - I have a copy of an unfinished essay I started writing on why I had given up tucked away somewhere. ", "parent": "Prometheus.txt", "score": 0.5225567817687988}, {"content": "I hate how flat computer interfaces are. I hate how disembodied sitting in front of a screen makes me feel. I hate straining my eyes to dig through a mountain of text, while my other senses lay unused and completely idle. I hate gigantic codebases with massive piles of dependencies and hour long build processes, where you must test every little idea you have against a mountain of assumptions to make sure it doesn't break anything.", "parent": "NOW PAGE.txt", "score": 0.5275231599807739}, {"content": "I read Rich Harris' twitter thread on how Javascript with JSDoc is actually pretty good, and decided to give it a shot. To be clear, I'm not blaming Rich Harris for my choice - he qualified his point, saying JS with JSDoc is preferable to Typescript for library development, because not having an intermediate build step makes it easier to reproduce bugs in a REPL. He still recommends using Typescript for projects (I think), so I was acting against his advice here. ", "parent": "The making of Nomad Hypertext.txt", "score": 0.5508190393447876}, {"content": "Front end development should be way more visual. A great deal of front-end development pain points cannot be fixed with fancier libraries and languages, because the fundamental mismatch is trying to create something visual with a text-based tool.[[code]] [[ideas]] [[tools for thought]] ", "parent": "untitled-9-24-2021.txt", "score": 0.5601890087127686}, {"content": "I opted to use Javascript instead of Typescript out of mix of curiosity and laziness. Like most people, I was introduced to Javascript before I was introduced to Typescript. Like most people, I suffered through many null errors and was relieved when I discovered that the Typescript compiler could save me from many of them. Like most people, though I am grateful for Typescript, I find it occasionally cumbersome. ", "parent": "The making of Nomad Hypertext.txt", "score": 0.5723859667778015}, {"content": "Why not Tauri? With Tauri you have to write your backend routes in Rust. Surprisingly, I could not find any in-memory vector databases in Rust. I also have never written Rust in my life, though I would have been happy to pick it up to avoid using Electron. More importantly, I don't think there was a library that would have let me run Hugging Face's text embedding model in Rust. For these reasons, I had to use JS for my backend, which meant I had to use Electron. ", "parent": "The making of Nomad Hypertext.txt", "score": 0.5762507915496826}, {"content": "You might object: Just because the vector DB and text embedding model are tied to JS doesn't mean your whole application does! You'd be right. I could have rolled the vector DB and text embedding model into a separate executable, compiling a node wrapper around those libraries into their own executables, then calling those executables from my Tauri app with IPC.", "parent": "The making of Nomad Hypertext.txt", "score": 0.5780836939811707}, {"content": "It ended up taking the rest of the summer. I was 19, naive, and had no idea what a nightmare the contenteditable HTML standard was.", "parent": "Plaintext is your best friend.txt", "score": 0.5934643745422363}], "Why not Tauri? With Tauri you have to write your backend routes in Rust. Surprisingly, I could not find any in-memory vector databases in Rust. I also have never written Rust in my life, though I would have been happy to pick it up to avoid using Electron. More importantly, I don't think there was a library that would have let me run Hugging Face's text embedding model in Rust. For these reasons, I had to use JS for my backend, which meant I had to use Electron. ": [{"content": "Why not Tauri? With Tauri you have to write your backend routes in Rust. Surprisingly, I could not find any in-memory vector databases in Rust. I also have never written Rust in my life, though I would have been happy to pick it up to avoid using Electron. More importantly, I don't think there was a library that would have let me run Hugging Face's text embedding model in Rust. For these reasons, I had to use JS for my backend, which meant I had to use Electron. ", "parent": "The making of Nomad Hypertext.txt", "score": 1.1920928955078125e-07}, {"content": "You might object: Just because the vector DB and text embedding model are tied to JS doesn't mean your whole application does! You'd be right. I could have rolled the vector DB and text embedding model into a separate executable, compiling a node wrapper around those libraries into their own executables, then calling those executables from my Tauri app with IPC.", "parent": "The making of Nomad Hypertext.txt", "score": 0.418525755405426}, {"content": "The two big shortcuts I took were using Javascript instead of Typescript and using Electron instead of Tauri. ", "parent": "The making of Nomad Hypertext.txt", "score": 0.43955403566360474}, {"content": "I want to learn more code. Working on [[exegesis]] over the course of a year, I saw my coding ability improve substantially. Towards the last 2 months, while rewriting a part of the codebase, I found myself dumbfounded by some of the decisions and patterns I had used a year earlier. The code I wrote towards the end was noticeably cleaner and more maintainable, mostly because I had familiarized myself with [[React]] hooks. Learning NextJS and GraphQL was also very rewarding, and both technologies were used extensively in the final version of exegesis. Looking forwards, I am thinking about learning Go, Clojure and maybe Rust. Go is the most practical one of all these for my purposes, and could open up a lot of job offers. Clojure is the most interesting from a theoretical standpoint, since I've never used a lisp or functional language. Rust is interesting because I hate systems/low-level programming, but I suspect that might only be because I hate C, and maybe Rust's more modern features will sell me on it. ", "parent": "Reflections for the New Year.txt", "score": 0.508080244064331}, {"content": "The vision is to have a tool that provides a visual interface for creating layouts, and maybe even rigging up basic stateful logic, or data fetching logic. I've more or less nailed down a preferred personal stack for creating projects with React, Express and Postgres, so it shouldn't be terribly difficult to even integrate database logic/fetching logic into such a tool (so long as some flexibility is lost on technology choice).[[code]] [[ideas]] [[tools for thought]] ", "parent": "untitled-9-24-2021.txt", "score": 0.531753659248352}, {"content": "In any case I wanted to try something new because that's what Recurse is all about, so I tried making a project with just JS and JSDoc for some semblance of type safety. ", "parent": "The making of Nomad Hypertext.txt", "score": 0.5543854832649231}, {"content": "I opted to use Javascript instead of Typescript out of mix of curiosity and laziness. Like most people, I was introduced to Javascript before I was introduced to Typescript. Like most people, I suffered through many null errors and was relieved when I discovered that the Typescript compiler could save me from many of them. Like most people, though I am grateful for Typescript, I find it occasionally cumbersome. ", "parent": "The making of Nomad Hypertext.txt", "score": 0.5549517869949341}, {"content": "I read Rich Harris' twitter thread on how Javascript with JSDoc is actually pretty good, and decided to give it a shot. To be clear, I'm not blaming Rich Harris for my choice - he qualified his point, saying JS with JSDoc is preferable to Typescript for library development, because not having an intermediate build step makes it easier to reproduce bugs in a REPL. He still recommends using Typescript for projects (I think), so I was acting against his advice here. ", "parent": "The making of Nomad Hypertext.txt", "score": 0.5603830814361572}, {"content": "However, when building Yurt, the static site builder for nomad hypertext, I found myself repeating a lot of logic. I found myself wanting to add features to the indexing engine, like being able to use cloud providers instead of local models (because doing all this processing locally can take ages!). In the future, I might want to use multimodal models, so I can see similarity between images, text, and audio. ", "parent": "The making of Nomad Hypertext.txt", "score": 0.5647128820419312}, {"content": "Electron really, really, really sucks. For starters, you have to use CommonJS. That itself would be bad enough, but there are a huge pile of other inconveniences that Electron dumps on you: Using window.prompt() doesn't work (because it blocks the main thread apparently) and it generates HUGE executables without making the slightest effort to tree-shake anything (it was literally bundling in sample text files I was using in the repo). Creating my own window.prompt() alternative was an interesting exercise, but I wish I wasn't forced into doing it.", "parent": "The making of Nomad Hypertext.txt", "score": 0.5762507915496826}], "You might object: Just because the vector DB and text embedding model are tied to JS doesn't mean your whole application does! You'd be right. I could have rolled the vector DB and text embedding model into a separate executable, compiling a node wrapper around those libraries into their own executables, then calling those executables from my Tauri app with IPC.": [{"content": "You might object: Just because the vector DB and text embedding model are tied to JS doesn't mean your whole application does! You'd be right. I could have rolled the vector DB and text embedding model into a separate executable, compiling a node wrapper around those libraries into their own executables, then calling those executables from my Tauri app with IPC.", "parent": "The making of Nomad Hypertext.txt", "score": 4.172325134277344e-07}, {"content": "Why not Tauri? With Tauri you have to write your backend routes in Rust. Surprisingly, I could not find any in-memory vector databases in Rust. I also have never written Rust in my life, though I would have been happy to pick it up to avoid using Electron. More importantly, I don't think there was a library that would have let me run Hugging Face's text embedding model in Rust. For these reasons, I had to use JS for my backend, which meant I had to use Electron. ", "parent": "The making of Nomad Hypertext.txt", "score": 0.4184234142303467}, {"content": "The two big shortcuts I took were using Javascript instead of Typescript and using Electron instead of Tauri. ", "parent": "The making of Nomad Hypertext.txt", "score": 0.5180846452713013}, {"content": "I avoided this IPC-executable approach because I thought it'd be really complicated. To some extent, this was the correct decision - I'm glad I got a MVP of my project out during my time at Recurse. ", "parent": "The making of Nomad Hypertext.txt", "score": 0.5340895652770996}, {"content": "However, when building Yurt, the static site builder for nomad hypertext, I found myself repeating a lot of logic. I found myself wanting to add features to the indexing engine, like being able to use cloud providers instead of local models (because doing all this processing locally can take ages!). In the future, I might want to use multimodal models, so I can see similarity between images, text, and audio. ", "parent": "The making of Nomad Hypertext.txt", "score": 0.5653012990951538}, {"content": "The vision is to have a tool that provides a visual interface for creating layouts, and maybe even rigging up basic stateful logic, or data fetching logic. I've more or less nailed down a preferred personal stack for creating projects with React, Express and Postgres, so it shouldn't be terribly difficult to even integrate database logic/fetching logic into such a tool (so long as some flexibility is lost on technology choice).[[code]] [[ideas]] [[tools for thought]] ", "parent": "untitled-9-24-2021.txt", "score": 0.576141357421875}, {"content": "Electron really, really, really sucks. For starters, you have to use CommonJS. That itself would be bad enough, but there are a huge pile of other inconveniences that Electron dumps on you: Using window.prompt() doesn't work (because it blocks the main thread apparently) and it generates HUGE executables without making the slightest effort to tree-shake anything (it was literally bundling in sample text files I was using in the repo). Creating my own window.prompt() alternative was an interesting exercise, but I wish I wasn't forced into doing it.", "parent": "The making of Nomad Hypertext.txt", "score": 0.5781349539756775}, {"content": "Factoring out the semantic search element of my app would have been the correct, unix-ey thing to do, and it would allow me to make these extensions in the future. I plan on doing this soon.  ", "parent": "The making of Nomad Hypertext.txt", "score": 0.579196572303772}, {"content": "Since the content is in an interoperable format, I can build software on top of my content without touching or modifying existing code. ", "parent": "NOW PAGE.txt", "score": 0.6128992438316345}, {"content": "In any case I wanted to try something new because that's what Recurse is all about, so I tried making a project with just JS and JSDoc for some semblance of type safety. ", "parent": "The making of Nomad Hypertext.txt", "score": 0.613344132900238}], "I avoided this IPC-executable approach because I thought it'd be really complicated. To some extent, this was the correct decision - I'm glad I got a MVP of my project out during my time at Recurse. ": [{"content": "I avoided this IPC-executable approach because I thought it'd be really complicated. To some extent, this was the correct decision - I'm glad I got a MVP of my project out during my time at Recurse. ", "parent": "The making of Nomad Hypertext.txt", "score": 0.0}, {"content": "To be frank, I made some regrettable engineering decisions while making Nomad Hypertext. I built this during my Recurse Center batch and was focused on getting a working prototype out, so some shortcuts were taken. Nevertheless, reflecting back, I would say these shortcuts were not worth it. ", "parent": "The making of Nomad Hypertext.txt", "score": 0.4930524230003357}, {"content": "In any case I wanted to try something new because that's what Recurse is all about, so I tried making a project with just JS and JSDoc for some semblance of type safety. ", "parent": "The making of Nomad Hypertext.txt", "score": 0.5237373113632202}, {"content": "You might object: Just because the vector DB and text embedding model are tied to JS doesn't mean your whole application does! You'd be right. I could have rolled the vector DB and text embedding model into a separate executable, compiling a node wrapper around those libraries into their own executables, then calling those executables from my Tauri app with IPC.", "parent": "The making of Nomad Hypertext.txt", "score": 0.5340538024902344}, {"content": "Working on exegesis was a grueling affair at times. I rewrote the schema multiple times, rewrote the backend from scratch 2 months before release, chased countless UI bugs, and manually patched abandoned NPM packages. Part of it may have been due to my inexperience, but [working with ](https://nichwch.medium.com/making-yana-e3fade3f56e7)[rich text](https://medium.engineering/why-contenteditable-is-terrible-122d8a40e480) is just a [difficult task](https://twitter.com/thesephist/status/1360298464349999108), period. At one point, I considered giving up after finding a rival writing app I thought I simply couldn't compete with - I have a copy of an unfinished essay I started writing on why I had given up tucked away somewhere. ", "parent": "Prometheus.txt", "score": 0.5369775295257568}, {"content": "The results were... mixed. I did get to move faster at the start, but started running into more and more type-related bugs as development went on. If I were to do this project again, I'd stick to Typescript. ", "parent": "The making of Nomad Hypertext.txt", "score": 0.539352536201477}, {"content": "This was reassuring, because it meant I had made something genuinely useful. In the past, I have made things I simply had no desire to use - one example is [JAFT](https://nichwch.medium.com/what-is-jaft-f543a4fad9d7), a time tracking app I made after making YANA (the predecessor to exegesis). I stopped using it after a bit, and didn't bother renewing the domain. I don't miss JAFT at all. The fact that I did miss exegesis on the days where it wasn't operational was a good sign.", "parent": "Second Brains.txt", "score": 0.5508790016174316}, {"content": "This is not groundbreaking news, but it's groundbreaking for me. I started my software engineering career writing code with cloud applications in mind, and the idea that you can ship cool projects without running database migrations or doing extensive backtesting against your monolith *is* groundbreaking to me. In college I wanted my own blog and instead of getting a static site generator I built out a cloud application with NextJS, PostgreSQL and Heroku. I did learn a lot and it helped me land my first internship, but now it strikes me as an incredibly wrong minded approach. ", "parent": "NOW PAGE.txt", "score": 0.5598317980766296}, {"content": "I want to learn more code. Working on [[exegesis]] over the course of a year, I saw my coding ability improve substantially. Towards the last 2 months, while rewriting a part of the codebase, I found myself dumbfounded by some of the decisions and patterns I had used a year earlier. The code I wrote towards the end was noticeably cleaner and more maintainable, mostly because I had familiarized myself with [[React]] hooks. Learning NextJS and GraphQL was also very rewarding, and both technologies were used extensively in the final version of exegesis. Looking forwards, I am thinking about learning Go, Clojure and maybe Rust. Go is the most practical one of all these for my purposes, and could open up a lot of job offers. Clojure is the most interesting from a theoretical standpoint, since I've never used a lisp or functional language. Rust is interesting because I hate systems/low-level programming, but I suspect that might only be because I hate C, and maybe Rust's more modern features will sell me on it. ", "parent": "Reflections for the New Year.txt", "score": 0.5642053484916687}, {"content": "Why did it take so long? Part of it is just a lack of experience. While making exegesis, I changed the database schema countless times, wrote dozens of migrations, accidentally wiped my database once (thank God for RDS backups), and rewrote the backend from scratch 2 months before release. There was also a good amount of feature creep. Whenever I thought I was close to finished, something unexpected would pop up - I started writing this essay 3 months before I actually released exegesis. Whatever the reason, if you count development time on the predecessor to exegesis, I've spent almost a tenth of my life building this. The entire project clocks in at a couple thousand lines of code. It is the largest, most complex, and most difficult thing I have built so far in my life.  [The last time I worked on a project this long, it was the first video game I made back in my senior year of high school.](https://medium.com/@nichwch/machine-gods-devlog-1-166dff474366) Even then, it was really about 6 months of development total, with a huge gap in between because of school, and it was all made with no-code game development tools, because back then the idea of using actual code terrified me. [[exegesis]] [[personal-reflection]] ", "parent": "Reflections on exegesis.txt", "score": 0.5724701881408691}], "However, when building Yurt, the static site builder for nomad hypertext, I found myself repeating a lot of logic. I found myself wanting to add features to the indexing engine, like being able to use cloud providers instead of local models (because doing all this processing locally can take ages!). In the future, I might want to use multimodal models, so I can see similarity between images, text, and audio. ": [{"content": "However, when building Yurt, the static site builder for nomad hypertext, I found myself repeating a lot of logic. I found myself wanting to add features to the indexing engine, like being able to use cloud providers instead of local models (because doing all this processing locally can take ages!). In the future, I might want to use multimodal models, so I can see similarity between images, text, and audio. ", "parent": "The making of Nomad Hypertext.txt", "score": 0.0}, {"content": "Yurt is a static site generator, built off the same principles as Nomad Hypertext. ", "parent": "What is Yurt.txt", "score": 0.3195134997367859}, {"content": "One last thing: There is a solution that combines the flexibility of plaintext with the aesthetics of rich text - Markdown! I don't think I'll support Markdown formatting in nomad hypertext, but for my static site generator Yurt, I will try to do that in the future. The utility would mostly be from having usable links. ", "parent": "Plaintext is your best friend.txt", "score": 0.3951148986816406}, {"content": "There are pros and cons to this approach. The biggest pro is that it generates a static blog. There's no backend to maintain, and it's quite lightweight and loads fast, while also providing the benefit of semantic hyperlinks. The con is that since the index is precomputed, you can't search for arbitrary things like you can in nomad hypertext. ", "parent": "What is Yurt.txt", "score": 0.40189868211746216}, {"content": "To be frank, I made some regrettable engineering decisions while making Nomad Hypertext. I built this during my Recurse Center batch and was focused on getting a working prototype out, so some shortcuts were taken. Nevertheless, reflecting back, I would say these shortcuts were not worth it. ", "parent": "The making of Nomad Hypertext.txt", "score": 0.4808785915374756}, {"content": "At the Recurse center, grinding leetcode and working on nomad hypertext, a collection of interface ideas that center around local-first notetaking powered by semantic search and AI. ", "parent": "NOW-Jan-05-2024.txt", "score": 0.4818646311759949}, {"content": "I was greatly inspired by two blogposts. The first, [Hyperlink Maximalism](https://thesephist.com/posts/hyperlink/) by Linus Lee talks about generating hyperlinks automatically between documents, and comes with a [demo](https://notation.app) that made a deep impression on me. To be honest, nomad hypertext is just Linus' demo using semantic search instead of full text search.", "parent": "What is Nomad Hypertext.txt", "score": 0.48288190364837646}, {"content": "Nomad Hypertext is a writing app built around semantic search. ", "parent": "What is Nomad Hypertext.txt", "score": 0.48559999465942383}, {"content": "I rewrote the indexing software for this blog in Python. The general philosophy of keeping things as modular as possible, storing content in interoperable, plain formats whenever possible, has been paying off. I'm realizing slowly how many other possibilities are opened up by keeping content in plaintext/markdown - I can write a weekend project mapping my blog posts by topic and time, I can create a word cloud visualization of my blog, I can build a game of pong where the blocks are paragraphs of my blogposts, all without touching any existing code. ", "parent": "NOW PAGE.txt", "score": 0.4859575033187866}, {"content": "You're viewing this on a statically generated blog using Yurt! ", "parent": "What is Yurt.txt", "score": 0.5017818212509155}], "Factoring out the semantic search element of my app would have been the correct, unix-ey thing to do, and it would allow me to make these extensions in the future. I plan on doing this soon.  ": [{"content": "Factoring out the semantic search element of my app would have been the correct, unix-ey thing to do, and it would allow me to make these extensions in the future. I plan on doing this soon.  ", "parent": "The making of Nomad Hypertext.txt", "score": 3.874301910400391e-06}, {"content": "The basic idea here is that semantic search functions better than backlinking, tags, or folders at helping you see connections between your ideas. It is also much simpler to implement. With backlinks and tags, you often need specialized file types, but semantic search works on top of plain text. ", "parent": "What is Nomad Hypertext.txt", "score": 0.49692267179489136}, {"content": "Powered by semantic search", "parent": "What is Nomad Hypertext.txt", "score": 0.511483750285074}, {"content": "What he says about links, I believe to be true about semantic search. ", "parent": "What is Nomad Hypertext.txt", "score": 0.5463541746139526}, {"content": "However, when building Yurt, the static site builder for nomad hypertext, I found myself repeating a lot of logic. I found myself wanting to add features to the indexing engine, like being able to use cloud providers instead of local models (because doing all this processing locally can take ages!). In the future, I might want to use multimodal models, so I can see similarity between images, text, and audio. ", "parent": "The making of Nomad Hypertext.txt", "score": 0.5566679239273071}, {"content": "I want to continue working on [[exegesis]]. There are still a plethora of features I want to build into the app. I have wanted to build something like this for a long time - I sort of did with my last project [YANA](https://yananotes.com/), but the core text engine was so limited that I had to start over from scratch (the product of which is exegesis). I want to sort out a formal list of features before a beta release, and an eventual public release. I will probably use exegesis as a devlog of sorts as well.", "parent": "Reflections for the New Year.txt", "score": 0.5570074319839478}, {"content": "Working on a refactor for [[exegesis]] and [[synesthesia]], thinking about how to budget time. Working strategy is to take estimate for each feature, and double the time for each to account for stupid roadblocks (wifi not working, interrupted by something, bad documentation, etc. etc.) [[code]] [[devlog]] ", "parent": "untitled-9-21-2021.txt", "score": 0.5738465785980225}, {"content": "I avoided this IPC-executable approach because I thought it'd be really complicated. To some extent, this was the correct decision - I'm glad I got a MVP of my project out during my time at Recurse. ", "parent": "The making of Nomad Hypertext.txt", "score": 0.5789666175842285}, {"content": "You might object: Just because the vector DB and text embedding model are tied to JS doesn't mean your whole application does! You'd be right. I could have rolled the vector DB and text embedding model into a separate executable, compiling a node wrapper around those libraries into their own executables, then calling those executables from my Tauri app with IPC.", "parent": "The making of Nomad Hypertext.txt", "score": 0.5791600942611694}, {"content": "Nomad Hypertext is a writing app built around semantic search. ", "parent": "What is Nomad Hypertext.txt", "score": 0.5798724889755249}], "  ": [{"content": "  ", "parent": "The making of Nomad Hypertext.txt", "score": 1.1920928955078125e-07}, {"content": " ", "parent": "NOW PAGE.txt", "score": 0.08620893955230713}, {"content": " ", "parent": "untitled-10-11-2021.txt", "score": 0.08624202013015747}, {"content": " ", "parent": "Plaintext is your best friend.txt", "score": 0.08624202013015747}, {"content": "~", "parent": "Second Brains.txt", "score": 0.6585879325866699}, {"content": "~", "parent": "What is Nomad Hypertext.txt", "score": 0.6586077809333801}, {"content": "~", "parent": "Fragments.txt", "score": 0.6586195230484009}, {"content": "~", "parent": "The making of Nomad Hypertext.txt", "score": 0.6586399078369141}, {"content": "~", "parent": "What is Nomad Hypertext.txt", "score": 0.6586399078369141}, {"content": "~", "parent": "What is Nomad Hypertext.txt", "score": 0.6586399078369141}]}